# WARNING: project is not production ready until it will be in `main` branch.

# NanoPb C++ 

Extends C++ support for the [nanopb].

## Features

* Template-based classes with static methods for converters.
* One-line call encode/decode for complicated messages.

## Supported types:

* `NanoPb::AbstractScalarConverter` - Basic scalar type like `enum`.
* `NanoPb::AbstractMessageConverter` - Converter for messages.
* `NanoPb::AbstractUnionMessageConverter` - Converter for union (oneof) messages.
* `NanoPb::AbstractCallbackConverter` - Converter for callbacks.
* `NanoPb::StringConverter` - Converter for variable size string, mapped to `std::string`.
* `NanoPb::ArrayUnsignedConverter` - Repeated convertor for `std::vector<unsigned>` or `std::list<unsigned>` (Also support other signed types: `uint64_t`, `uint32_t`, etc).
* `NanoPb::ArraySignedConverter` - Repeated convertor for `std::vector<int>` or `std::list<int>` (Also support other signed types: `int64_t`, `int32_t`, etc).
* `NanoPb::ArrayStringConverter` - Repeated convertor for `std::vector<std::string>` or `std::list<std::string>`.
* `NanoPb::ArrayMessageConverter` - Repeated convertor for `std::vector<CLASS>` or `std::list<CLASS>`, NOTE: `AbstractMessageConverter` for  `CLASS` should be defined. 
* `NanoPb::MapConverter` - Map with any type of the key and value.

## Usage

### CMake steps

* Use `add subdirectory()` or `CPMAddPackage()` from [CPM] to add **nanopb_cpp** to your CMake project.  
* Set NANOPB_ROOT variable to use your own nanopb location, instead of downloading it via [CPM].
* Use `target_link_libraries(YOUR_TARGET nanopb_cpp)` to add dependency.

### Manual steps

* Install [nanopb]. Generate code from it.
* Add [nanopb_cpp.cpp](nanopb_cpp.cpp) to your project sources.
* Use `#include nanopb_cpp.h` in your code.

### Common steps

* Define C++ `class/struct` for each protobuf message generated by [nanopb].
* Define converter for each v/protobuf message pair, inherit from `NanoPb::AbstractMessageConverter`.
* Define callback converters for callback field, inherit from `NanoPb::AbstractCallbackConverter`.

## Limitations

* All C++ classes should have default constructor
* All C++ classes should have copy constructor or move constructor

## Examples

See [examples](examples) folder for the examples.
Also, you can find more examples in [tests](test/tests) folder.

### Basic string example:

#### Protobuf:

```protobuf
syntax = "proto3";

package PROTO;

message TestMessage {
  string str = 1;
}
```

#### C++ local model:

```c++
struct LOCAL_TestMessage {
    std::string str;

    LOCAL_TestMessage() = default;
    LOCAL_TestMessage(const LOCAL_TestMessage&) = delete;
    LOCAL_TestMessage(LOCAL_TestMessage&&) = default;
};
```

#### Converter:

```c++
using namespace NanoPb::Converter;

class TestMessageConverter : public AbstractMessageConverter<
        TestMessageConverter,
        LOCAL_TestMessage,
        PROTO_TestMessage,
        &PROTO_TestMessage_msg>
{
public:
    static ProtoType encoderInit(const LocalType& local) {
        return ProtoType{
                .str = StringConverter::encoderInit(local.str)
        };
    }

    static ProtoType decoderInit(LocalType& local){
        return ProtoType{
                .str = StringConverter::decoderInit(local.str)
        };
    }

    static bool decoderApply(const ProtoType& proto, LocalType& local){
        return true;
    }
};
```

#### Usage:

```c++
const LOCAL_TestMessage original(
        {"My super string"}
        );

// Define output stream. 
// NOTE: max size is just for nanopb limit, actual buffer will grow on demand.
NanoPb::StringOutputStream outputStream(65535);

// Encode
if (!NanoPb::encode<TestMessageConverter>(outputStream, original)){
    // encode error
}

// Define input stream
auto inputStream = NanoPb::StringInputStream(outputStream.release());

LOCAL_TestMessage decoded;

/// Decode message
if (!NanoPb::decode<TestMessageConverter>(inputStream, decoded)){
    // decode error
}
```

[nanopb]: https://github.com/nanopb/nanopb
[CPM]: https://github.com/cpm-cmake/CPM.cmake
